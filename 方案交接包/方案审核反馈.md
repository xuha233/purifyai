# æ–¹æ¡ˆå®¡æ ¸åé¦ˆä¸æ”¹è¿›å»ºè®®

> å®¡æ ¸æ—¥æœŸ: 2026-02-21  
> å®¡æ ¸äºº: æ¶æ„å®¡æ ¸å›¢é˜Ÿ  
> æ–‡æ¡£ç‰ˆæœ¬: v1.0

---

## æ€»ä½“è¯„ä»·

âœ… **æ–¹æ¡ˆæˆç†Ÿåº¦**: è‰¯å¥½ - æ¶æ„æ¸…æ™°ã€åŠŸèƒ½å®Œæ•´ã€å®æ–½è·¯å¾„æ˜ç¡®  
âš ï¸ **éœ€æ”¹è¿›é¡¹**: 7ä¸ªå…³é”®é—®é¢˜ç‚¹  
ğŸ’¡ **ä¼˜åŒ–å»ºè®®**: 5å¤„å¯ä¼˜åŒ–è®¾è®¡

---

## ä¸€ã€ å…³é”®é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜1: æ•°æ®åº“è®¾è®¡å­˜åœ¨å†—ä½™ âš ï¸

**å½“å‰é—®é¢˜**:
```sql
-- cleanup_items è¡¨é‡å¤å­˜å‚¨äº†å¤§é‡æ–‡æœ¬å­—æ®µ
cleanup_items (
    path TEXT NOT NULL,           -- å¯èƒ½å¾ˆé•¿çš„è·¯å¾„
    ai_reason TEXT,               -- AIåŸå› æ–‡æœ¬
    ...
)
```

**å½±å“**:
- æ‰«æ10ä¸‡é¡¹æ—¶ï¼Œæ•°æ®åº“ä½“ç§¯å¯èƒ½>100MB
- æŸ¥è¯¢æ€§èƒ½ä¸‹é™
- å¤‡ä»½/å¯¼å‡ºè€—æ—¶

**å»ºè®®æ”¹è¿›**:

```sql
-- æ–¹æ¡ˆA: åˆ†ç¦»å¤§å­—æ®µ
cleanup_items (
    id INTEGER PRIMARY KEY,
    plan_id TEXT NOT NULL,
    path_hash TEXT NOT NULL,     -- è·¯å¾„çš„å“ˆå¸Œå€¼
    size INTEGER NOT NULL,
    ...
);

-- æ–°å¢è·¯å¾„æ˜ å°„è¡¨ï¼ˆé¿å…é‡å¤å­˜å‚¨ï¼‰
item_paths (
    path_hash TEXT PRIMARY KEY,
    path TEXT NOT NULL
);

-- æ–¹æ¡ˆB: JSONå­˜å‚¨ï¼ˆæ›´çµæ´»ï¼‰
cleanup_items (
    id INTEGER PRIMARY KEY,
    plan_id TEXT NOT NULL,
    item_json TEXT NOT NULL,     -- å®Œæ•´JSONå­˜å‚¨
    ...
);
```

**æ¨è**: æ–¹æ¡ˆAï¼Œæ›´åˆ©äºæŸ¥è¯¢å’Œç´¢å¼•

---

### é—®é¢˜2: å†…å­˜å ç”¨ä¼°ç®—ä¸è¶³ âš ï¸

**å½“å‰ä¼°ç®—**:
- ç›®æ ‡: < 500MB
- 10ä¸‡é¡¹æ‰«æ

**å®é™…æµ‹ç®—**:
```python
# å•ä¸ªScanItemå¯¹è±¡å†…å­˜å ç”¨ä¼°ç®—
ScanItemå¯¹è±¡ ~ 1KB (åŒ…å«pathå­—ç¬¦ä¸²ã€datetimeç­‰)
10ä¸‡é¡¹ = 100MB

# CleanupPlanåŒ…å«æ‰€æœ‰é¡¹çš„å®Œæ•´å‰¯æœ¬
CleanupPlan ~ 100MB Ã— 3 (safe/suspicious/dangerousä¸‰ä»½å¼•ç”¨) = 300MB

# UIæ˜¾ç¤ºéœ€è¦é¢å¤–ç¼“å­˜
UIç¼“å­˜ ~ 50-100MB

# æ€»è®¡: 450-500MB (å·²æ¥è¿‘ä¸Šé™)
```

**å»ºè®®æ”¹è¿›**:

```python
class CleanupPlan:
    """ä¼˜åŒ–åçš„æ¸…ç†è®¡åˆ’"""
    
    def __init__(self):
        # æ”¹ä¸ºä½¿ç”¨å¼±å¼•ç”¨æˆ–IDç´¢å¼•ï¼Œè€Œéå®Œæ•´å¯¹è±¡
        self._safe_item_ids: List[str] = []     # åªå­˜å‚¨ID
        self._suspicious_item_ids: List[str] = []
        self._dangerous_item_ids: List[str] = []
        
        # ç»Ÿä¸€å­˜å‚¨æ‰€æœ‰é¡¹çš„ç´¢å¼•
        self._item_index: Dict[str, CleanupItem] = {}
        
    @property
    def safe_items(self) -> List[CleanupItem]:
        """æ‡’åŠ è½½ï¼ŒæŒ‰éœ€è·å–"""
        return [self._item_index[id] for id in self._safe_item_ids]
    
    def add_safe_item(self, item: CleanupItem):
        """æ·»åŠ å®‰å…¨é¡¹"""
        self._safe_item_ids.append(item.id)
        self._item_index[item.id] = item
```

**ä¼˜åŒ–æ•ˆæœ**: å†…å­˜å ç”¨é™ä½çº¦40-50%

---

### é—®é¢˜3: AI API è°ƒç”¨æˆæœ¬æœªè€ƒè™‘ âš ï¸

**å½“å‰è®¾è®¡**:
- æ¯æ‰¹50é¡¹
- 10ä¸‡é¡¹ = 2000æ¬¡AIè°ƒç”¨

**æˆæœ¬ä¼°ç®—** (ä»¥æ™ºè°±GLMä¸ºä¾‹):
- GLM-4-flash: Â¥0.001/åƒtokens
- æ¯æ¬¡è°ƒç”¨~1000 tokens
- 2000æ¬¡ Ã— Â¥0.001 = Â¥2/æ¬¡æ‰«æ

**å»ºè®®æ”¹è¿›**:

```python
class AIAnalyzer:
    """æˆæœ¬ä¼˜åŒ–çš„AIåˆ†æå™¨"""
    
    def __init__(self):
        self.config = get_config_manager().get('smart_clean', {})
        self.batch_size = self.config.get('ai_batch_size', 50)
        self.cache_enabled = self.config.get('ai_cache_enabled', True)
        self.rule_fallback_threshold = self.config.get('rule_fallback_threshold', 3)
        
    def analyze_scan_results(self, items: List[ScanItem]) -> CleanupPlan:
        """ä¼˜åŒ–åçš„åˆ†ææµç¨‹"""
        
        # 1. ä¼˜å…ˆä½¿ç”¨ç¼“å­˜
        if self.cache_enabled:
            cached = self._load_from_cache(items)
            if cached:
                return cached
        
        # 2. é«˜æˆæœ¬è·¯å¾„ä¼˜å…ˆä½¿ç”¨è§„åˆ™å¼•æ“
        rule_evaluated = self._rule_engine_evaluate(items)
        
        # 3. åªå¯¹å¯ç–‘é¡¹ä½¿ç”¨AIï¼ˆå‡å°‘70%+çš„APIè°ƒç”¨ï¼‰
        suspicious_items = [
            item for item in items 
            if item.risk_level == RiskLevel.SUSPICIOUS
        ]
        
        # 4. æ‰¹é‡AIåˆ†æ
        ai_result = self._ai_batch_analyze(suspicious_items)
        
        # 5. åˆå¹¶ç»“æœ
        return self._merge_results(rule_evaluated, ai_result)
```

**é…ç½®æ–°å¢**:
```json
{
  "smart_clean": {
    "ai_batch_size": 50,              // æ‰¹å¤„ç†å¤§å°
    "ai_cache_enabled": true,          // å¯ç”¨ç¼“å­˜
    "ai_cache_days": 7,                // ç¼“å­˜ä¿ç•™7å¤©
    "rule_fallback_threshold": 3,      // AIå¤±è´¥3æ¬¡åé™çº§åˆ°è§„åˆ™å¼•æ“
    "cost_limit_per_scan": 1.0          // å•æ¬¡æ‰«ææˆæœ¬é™åˆ¶(å…ƒ)
  }
}
```

---

### é—®é¢˜4: å¤‡ä»½ç®¡ç†å™¨è®¾è®¡ä¸å¤Ÿè¯¦ç»† ğŸ’¡

**å½“å‰é—®é¢˜**:
- BackupManager åªåœ¨æ–‡æ¡£ä¸­æåŠï¼Œæœªè¯¦ç»†è®¾è®¡
- å¤‡ä»½ç­–ç•¥ä¸å¤Ÿæ˜ç¡®

**å»ºè®®è¡¥å……è®¾è®¡**:

```python
class BackupManager:
    """å¤‡ä»½ç®¡ç†å™¨"""
    
    def __init__(self):
        self.backup_dir = Path(get_config_manager().get('smart_clean/backup_dir'))
        self.backup_enabled = get_config_manager().get('smart_clean/backup_enabled')
        self.retention_days = get_config_manager().get('smart_clean/backup_retention_days', 7)
        
    def create_backup(self, item: CleanupItem) -> Optional[str]:
        """åˆ›å»ºå¤‡ä»½
        
        ç­–ç•¥:
        - Safeé¡¹: ä¸å¤‡ä»½ï¼ˆç›´æ¥åˆ é™¤ï¼‰
        - Suspiciousé¡¹: åˆ›å»ºç¡¬é“¾æ¥å¼•ç”¨ï¼ˆå‡ ä¹ä¸å ç©ºé—´ï¼‰
        - Dangerousé¡¹: å®Œæ•´å¤‡ä»½
        """
        
        if item.ai_risk == RiskLevel.SAFE:
            return None
        
        elif item.ai_risk == RiskLevel.SUSPICIOUS:
            # ç¡¬é“¾æ¥å¼•ç”¨
            return self._create_hardlink_backup(item)
        
        elif item.ai_risk == RiskLevel.DANGEROUS:
            # å®Œæ•´å¤‡ä»½
            return self._create_full_backup(item)
    
    def _create_hardlink_backup(self, item: CleanupItem) -> str:
        """åˆ›å»ºç¡¬é“¾æ¥å¼•ç”¨"""
        
        backup_path = self.backup_dir / "hardlinks" / item.id
        
        # åˆ›å»ºç¡¬é“¾æ¥
        try:
            subprocess.run([
                'mklink', '/H', str(backup_path), str(item.path)
            ], shell=True, check=True)
            return str(backup_path)
        except Exception as e:
            logger.warning(f"ç¡¬é“¾æ¥åˆ›å»ºå¤±è´¥ï¼Œé™çº§ä¸ºå®Œæ•´å¤‡ä»½: {e}")
            return self._create_full_backup(item)
    
    def _create_full_backup(self, item: CleanupItem) -> str:
        """åˆ›å»ºå®Œæ•´å¤‡ä»½"""
        
        backup_path = self.backup_dir / "full" / item.id
        
        # å¤åˆ¶æ–‡ä»¶
        shutil.copy2(item.path, backup_path)
        
        # è®°å½•å¤‡ä»½å…ƒæ•°æ®
        self._record_backup_metadata(item, backup_path)
        
        return str(backup_path)
    
    def cleanup_old_backups(self):
        """æ¸…ç†è¿‡æœŸå¤‡ä»½"""
        
        cutoff = datetime.now() - timedelta(days=self.retention_days)
        
        for backup_dir in [self.backup_dir / "full"]:
            if backup_dir.exists():
                for backup in backup_dir.glob("*"):
                    stat = backup.stat()
                    if datetime.fromtimestamp(stat.st_mtime) < cutoff:
                        backup.unlink()
```

---

### é—®é¢˜5: UIçº¿ç¨‹é˜»å¡é£é™© âš ï¸

**å½“å‰é—®é¢˜**:
- SmartExecutor åœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œ
- å¯èƒ½å¯¼è‡´UIå¡é¡¿

**å»ºè®®æ”¹è¿›**:

```python
class SmartExecutor(QObject):
    """æ™ºèƒ½æ‰§è¡Œå™¨ - ç¡®ä¿çº¿ç¨‹å®‰å…¨"""
    
    def execute_plan(self, plan: CleanupPlan) -> None:
        """å¯åŠ¨å¼‚æ­¥æ‰§è¡Œ"""
        
        # åˆ›å»ºå·¥ä½œçº¿ç¨‹
        self._thread = ExecuteThread(plan, self)
        self._thread.start()
        
        # ä¿¡å·è¿æ¥
        self._thread.progress.connect(self._on_progress)
        self._thread.item_completed.connect(self._on_item_completed)
        self._thread.complete.connect(self._on_complete)


class ExecuteThread(QThread):
    """æ‰§è¡Œçº¿ç¨‹"""
    
    progress = pyqtSignal(str)
    item_completed = pyqtSignal(str, bool)
    complete = pyqtSignal(ExecutionResult)
    
    def __init__(self, plan: CleanupPlan, executor: SmartExecutor):
        super().__init__()
        self.plan = plan
        self.executor = executor
    
    def run(self):
        """åœ¨çº¿ç¨‹ä¸­æ‰§è¡Œ"""
        
        result = ExecutionResult(
            plan_id=self.plan.plan_id,
            started_at=datetime.now(),
            status=ExecutionStatus.RUNNING
        )
        
        items_to_execute = self.plan.safe_items + self.plan.suspicious_items
        
        for i, item in enumerate(items_to_execute):
            # å‘é€è¿›åº¦ä¿¡å·ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
            self.progress.emit(f"æ­£åœ¨æ¸…ç† ({i+1}/{len(items_to_execute)}): {item.path}")
            
            # æ‰§è¡Œæ¸…ç†ï¼ˆæ— UIæ“ä½œï¼‰
            success = self.executor._execute_with_retry(item, result)
            
            # å‘é€å®Œæˆä¿¡å·
            self.item_completed.emit(item.path, success)
            
            # æ›´æ–°ç»“æœ
            if success:
                result.success_items += 1
                result.freed_size += item.size
            else:
                result.failed_items += 1
                result.failed_size += item.size
        
        result.completed_at = datetime.now()
        self.complete.emit(result)
```

---

### é—®é¢˜6: é”™è¯¯æ¢å¤æœºåˆ¶ä¸å®Œæ•´ âš ï¸

**å½“å‰é—®é¢˜**:
- æ¸…ç†å¤±è´¥åæ— æ³•æ¢å¤
- ç”¨æˆ·è¯¯æ“ä½œæ— æ³•æŒ½å›

**å»ºè®®è¡¥å……**:

```python
class RecoveryManager:
    """æ¢å¤ç®¡ç†å™¨"""
    
    def rollback_cleanup(self, plan_id: str) -> bool:
        """å›æ»šæ¸…ç†æ“ä½œ"""
        
        # 1. åŠ è½½æ¸…ç†è®¡åˆ’
        plan = self._load_plan_from_db(plan_id)
        
        # 2. æ¢å¤å·²æ¸…ç†çš„é¡¹
        for item in plan.safe_items + plan.suspicious_items:
            if item.status == CleanupStatus.SUCCESS:
                self._restore_item(item)
        
        return True
    
    def _restore_item(self, item: CleanupItem) -> bool:
        """æ¢å¤å•ä¸ªæ–‡ä»¶"""
        
        # ä»å¤‡ä»½æ¢å¤
        backup_path = self._find_backup(item.id)
        
        if backup_path and backup_path.exists():
            # å¤åˆ¶å›åŸä½ç½®
            shutil.copy2(backup_path, item.path)
            
            # å¦‚æœæ˜¯ç¡¬é“¾æ¥ï¼Œé‡å»ºç¡¬é“¾æ¥
            if self._is_hardlink(backup_path):
                backup_path.unlink()
                subprocess.run([
                    'mklink', '/H', str(item.path), str(backup_path.parent / item.id)
                ], shell=True)
            
            return True
        
        return False
```

**UIè¡¥å……**: æ·»åŠ "å›æ»š"æŒ‰é’®åˆ°æŠ¥å‘Šé¡µé¢

---

### é—®é¢˜7: æ€§èƒ½æŒ‡æ ‡è®¾å®šä¸åˆç† âš ï¸

**å½“å‰æŒ‡æ ‡**:
- 100GBç£ç›˜æ‰«æ < 30ç§’ï¼ˆä½¿ç”¨MFTï¼‰
- 10ä¸‡é¡¹AIåˆ†æ < 5åˆ†é’Ÿ

**å®é™…æµ‹è¯•æ•°æ®** (å‚è€ƒWinDirStat):

| æµ‹è¯•é¡¹ | å®é™…è€—æ—¶ | å½“å‰ç›®æ ‡ | åˆç†ç›®æ ‡ |
|-------|---------|---------|---------|
| 100GBç£ç›˜æ‰«æï¼ˆåŸºç¡€APIï¼‰ | ~2-5åˆ†é’Ÿ | <30ç§’ | <5åˆ†é’Ÿ (MFT) / <10åˆ†é’Ÿ (åŸºç¡€) |
| 10ä¸‡é¡¹AIåˆ†æ | ~15-20åˆ†é’Ÿ | <5åˆ†é’Ÿ | <20åˆ†é’Ÿ (åˆç†) |
| æ¸…ç†æ‰§è¡Œé€Ÿåº¦ | ~50-100é¡¹/ç§’ | >100é¡¹/ç§’ | >50é¡¹/ç§’ |

**å»ºè®®ä¿®æ­£**:

```python
# æ€§èƒ½åŸºå‡†é…ç½®
PERFORMANCE_BENCHMARKS = {
    'disk_scan_100gb_mft': {
        'target': 300,      # 5åˆ†é’Ÿ (ç§’)
        'warning': 600,     # 10åˆ†é’Ÿ
        'description': '100GBç£ç›˜æ‰«æï¼ˆMFTï¼‰'
    },
    'disk_scan_100gb_basic': {
        'target': 600,      # 10åˆ†é’Ÿ
        'warning': 900,     # 15åˆ†é’Ÿ
        'description': '100GBç£ç›˜æ‰«æï¼ˆåŸºç¡€APIï¼‰'
    },
    'ai_analysis_100k': {
        'target': 1200,     # 20åˆ†é’Ÿ
        'warning': 1800,    # 30åˆ†é’Ÿ
        'description': '10ä¸‡é¡¹AIåˆ†æ'
    },
    'cleanup_speed': {
        'target': 50,       # 50é¡¹/ç§’
        'warning': 20,      # 20é¡¹/ç§’
        'description': 'æ¸…ç†æ‰§è¡Œé€Ÿåº¦'
    },
    'memory_usage': {
        'target': 300,      # 300MB
        'warning': 500,     # 500MB
        'description': 'å†…å­˜å ç”¨å³°å€¼'
    }
}
```

---

## äºŒã€ ä¼˜åŒ–å»ºè®®

### å»ºè®®1: æ·»åŠ è¿›åº¦é¢„ä¼° ğŸ’¡

**å½“å‰**: åªæ˜¾ç¤º"å·²å¤„ç†: 1234/2000 é¡¹"

**ä¼˜åŒ–**: é¢„ä¼°å‰©ä½™æ—¶é—´

```python
class ProgressEstimator:
    """è¿›åº¦é¢„ä¼°å™¨"""
    
    def __init__(self):
        self.start_time = None
        self.processed_items = 0
        self.total_items = 0
        self.speed_samples = []  # é€Ÿåº¦é‡‡æ ·
    
    def start(self, total_items: int):
        """å¼€å§‹è®¡æ—¶"""
        self.start_time = time.time()
        self.total_items = total_items
        self.processed_items = 0
        self.speed_samples = []
    
    def update(self, processed: int):
        """æ›´æ–°è¿›åº¦"""
        self.processed_items = processed
        
        # è®¡ç®—å½“å‰é€Ÿåº¦
        elapsed = time.time() - self.start_time
        speed = processed / elapsed if elapsed > 0 else 0
        
        # é‡‡æ ·æœ€è¿‘30ç§’çš„é€Ÿåº¦
        self.speed_samples.append(speed)
        if len(self.speed_samples) > 30:
            self.speed_samples.pop(0)
    
    def get_estimation(self) -> dict:
        """è·å–é¢„ä¼°"""
        if not self.start_time or self.processed_items == 0:
            return {'remaining': 'è®¡ç®—ä¸­...'}
        
        elapsed = time.time() - self.start_time
        avg_speed = sum(self.speed_samples) / len(self.speed_samples) if self.speed_samples else 0
        
        remaining_items = self.total_items - self.processed_items
        remaining_time = remaining_items / avg_speed if avg_speed > 0 else 0
        
        return {
            'elapsed': self._format_time(elapsed),
            'remaining': self._format_time(remaining_time),
            'total': self._format_time(elapsed + remaining_time),
            'speed': f"{avg_speed:.1f} é¡¹/ç§’"
        }
    
    def _format_time(self, seconds: float) -> str:
        """æ ¼å¼åŒ–æ—¶é—´"""
        if seconds < 60:
            return f"{int(seconds)}ç§’"
        elif seconds < 3600:
            return f"{int(seconds // 60)}åˆ†{int(seconds % 60)}ç§’"
        else:
            hours = int(seconds // 3600)
            mins = int((seconds % 3600) // 60)
            return f"{hours}å°æ—¶{mins}åˆ†é’Ÿ"
```

**UIæ˜¾ç¤º**:
```
è¿›åº¦: 1,234 / 2,000 é¡¹ (61.7%)
é€Ÿåº¦: 156 é¡¹/ç§’
å·²ç”¨: 8åˆ†é’Ÿ  å‰©ä½™: 5åˆ†é’Ÿ  æ€»è®¡: 13åˆ†é’Ÿ
```

---

### å»ºè®®2: å¢åŠ æ‰«æé¢„æ£€æŸ¥ ğŸ’¡

**ç›®çš„**: é¿å…æ‰«æåæ‰å‘ç°æƒé™ä¸è¶³

```python
class ScanPreCheck:
    """æ‰«æé¢„æ£€æŸ¥"""
    
    def check_permissions(self, paths: List[str]) -> dict:
        """æ£€æŸ¥æƒé™"""
        
        results = {
            'valid': True,
            'errors': [],
            'warnings': []
        }
        
        for path in paths:
            # æ£€æŸ¥è·¯å¾„å­˜åœ¨
            if not os.path.exists(path):
                results['valid'] = False
                results['errors'].append(f"è·¯å¾„ä¸å­˜åœ¨: {path}")
                continue
            
            # æ£€æŸ¥è¯»å–æƒé™
            if not os.access(path, os.R_OK):
                results['errors'].append(f"æ— è¯»å–æƒé™: {path}")
            
           
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºç³»ç»Ÿè·¯å¾„
            if self._is_system_path(path):
                results['warnings'].append(f"ç³»ç»Ÿè·¯å¾„: {path} - è¯·è°¨æ…æ“ä½œ")
            
            # æ£€æŸ¥ç£ç›˜ç©ºé—´
            if os.path.isdir(path):
                drive = os.path.splitdrive(path)[0]
                free_space = self._get_free_space(drive)
                if free_space < 100 * 1024 * 1024:  # < 100MB
                    results['warnings'].append(f"ç£ç›˜ç©ºé—´ä¸è¶³: {drive}")
        
        results['valid'] = len(results['errors']) == 0
        return results
    
    def _is_system_path(self, path: str) -> bool:
        """æ˜¯å¦ä¸ºç³»ç»Ÿè·¯å¾„"""
        system_paths = [
            'C:\\Windows',
            'C:\\Program Files',
            'C:\\Program Files (x86)'
        ]
        return any(path.startswith(p) for p in system_paths)
```

**UIé›†æˆ**: æ‰«æå¼€å§‹å‰å¼¹å‡ºé¢„æ£€æŸ¥ç»“æœå¯¹è¯æ¡†

---

### å»ºè®®3: æ·»åŠ æ‰«ææš‚åœ/æ¢å¤åŠŸèƒ½ ğŸ’¡

**ä»·å€¼**: é•¿æ—¶é—´æ‰«æï¼ˆå¦‚å…¨ç›˜æ‰«æï¼‰å¯æš‚åœï¼Œé¿å…å ç”¨èµ„æº

```python
class PausableScanner(QObjectScanner):
    """å¯æš‚åœçš„æ‰«æå™¨"""
    
    def __init__(self):
        super().__init__()
        self._paused = False
        self._pause_condition = threading.Condition()
    
    def pause(self):
        """æš‚åœæ‰«æ"""
        with self._pause_condition:
            self._paused = True
    
    def resume(self):
        """æ¢å¤æ‰«æ"""
        with self._pause_condition:
            self._paused = False
            self._pause_condition.notify_all()
    
    def _check_pause(self):
        """æ£€æŸ¥æ˜¯å¦æš‚åœ"""
        with self._pause_condition:
            while self._paused:
                self._pause_condition.wait()
```

---

### å»ºè®®4: å®ç°æ‰«æç»“æœå¯¼å‡ºåŠŸèƒ½ ğŸ’¡

**ç›®çš„**: å…è®¸ç”¨æˆ·ä¿å­˜æ‰«æç»“æœï¼Œç”¨äºç¦»çº¿åˆ†æ

```python
class ScanResultExporter:
    """æ‰«æç»“æœå¯¼å‡ºå™¨"""
    
    def export_to_json(self, items: List[ScanItem], path: str):
        """å¯¼å‡ºä¸ºJSON"""
        
        data = {
            'export_time': datetime.now().isoformat(),
            'total_items': len(items),
            'total_size': sum(item.size for item in items),
            'items': [
                {
                    'path': item.path,
                    'size': item.size,
                    'item_type': item.item_type,
                    'risk_level': item.risk_level.value,
                    'last_modified': item.last_modified.isoformat() if item.last_modified else None
                }
                for item in items
            ]
        }
        
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    
    def export_to_csv(self, items: List[ScanItem], path: str):
        """å¯¼å‡ºä¸ºCSV"""
        
        with open(path, 'w', encoding='utf-8', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['è·¯å¾„', 'å¤§å°', 'ç±»å‹', 'é£é™©ç­‰çº§', 'æœ€åä¿®æ”¹æ—¶é—´'])
            
            for item in items:
                writer.writerow([
                    item.path,
                    item.size,
                    item.item_type,
                    item.risk_level.value,
                    item.last_modified.isoformat() if item.last_modified else ''
                ])
```

---

### å»ºè®®5: æ·»åŠ å•å…ƒæµ‹è¯•æ¡†æ¶ ğŸ’¡

**å½“å‰**: æ–¹æ¡ˆä¸­æåˆ°å•å…ƒæµ‹è¯•ï¼Œä½†æœªç»™å‡ºå…·ä½“æ¡†æ¶

**å»ºè®®**: ä½¿ç”¨ pytest

```python
# tests/test_smart_scan_selector.py
import pytest
from core.smart_scan_selector import SmartScanSelector


class TestSmartScanSelector:
    
    def test_select_system_scanner(self):
        """æµ‹è¯•ç³»ç»Ÿæ‰«æå™¨é€‰æ‹©"""
        selector = SmartScanSelector()
        scanner = selector.select_scanner('system', '')
        
        assert scanner is not None
        assert scanner.__class__.__name__ == 'SystemScanner'
    
    def test_select_custom_scanner(self):
        """æµ‹è¯•è‡ªå®šä¹‰æ‰«æå™¨é€‰æ‹©"""
        selector = SmartScanSelector()
        scanner = selector.select_scanner('custom', 'C:\\test')
        
        assert scanner is not None
        assert scanner.__class__.__name__ == 'DepthDiskScanner'
    
    def test_invalid_scan_type(self):
        """æµ‹è¯•æ— æ•ˆæ‰«æç±»å‹"""
        selector = SmartScanSelector()
        scanner = selector.select_scanner('invalid', '')
        
        assert scanner is None


# tests/test_ai_analyzer.py
import pytest
from unittest.mock import Mock, patch
from core.ai_analyzer import AIAnalyzer


class TestAIAnalyzer:
    
    @patch('core.ai_analyzer.get_ai_enhancer')
    def test_batch_size_split(self, mock_get_ai_enhancer):
        """æµ‹è¯•æ‰¹å¤„ç†åˆ†å‰²"""
        analyzer = AIAnalyzer()
        
        # åˆ›å»º100ä¸ªæ¨¡æ‹Ÿé¡¹
        items = [Mock() for _ in range(100)]
        
        # æ¨¡æ‹Ÿåˆ†æ‰¹
        batches = analyzer._split_batches(items, batch_size=50)
        
        assert len(batches) == 2
        assert len(batches[0]) == 50
        assert len(batches[1]) == 50


# pytest.ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --tb=short --strict-markers
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
```

---

## ä¸‰ã€ MVPèŒƒå›´ä¿®æ­£å»ºè®®

### å½“å‰MVPèŒƒå›´ vs å»ºè®®MVPèŒƒå›´

| åŠŸèƒ½ | å½“å‰MVP | å»ºè®®MVP | ç†ç”± |
|------|---------|---------|------|
| åŸºç¡€APIæ·±åº¦æ‰«æ | âœ… | âœ… | - |
| AIæ‰¹é‡åˆ†æ | âœ… | âš ï¸ ç®€åŒ–ç‰ˆ | ä»…å¯¹SUSPICIOUSé¡¹åˆ†æï¼Œé™ä½APIæˆæœ¬ |
| æ™ºèƒ½æ‰§è¡Œ(æ— å¤‡ä»½) | âœ… | âœ… | - |
| é«˜å±ç¡®è®¤å¯¹è¯æ¡† | âœ… | âœ… | - |
| ç®€åŒ–ç‰ˆæŠ¥å‘Š | âœ… | âœ… | - |
| NTFS MFT | âŒ V2 | âš ï¸ V1.5 | ç”¨æˆ·åé¦ˆåå†³å®šæ˜¯å¦æå‰ |
| å®Œæ•´å¤‡ä»½ | âŒ V2 | âŒ V2 | - |
| Treemapå¯è§†åŒ– | âŒ V2 | âŒ V2 | - |
| **è¿›åº¦é¢„ä¼°** | âŒ | âœ… | **å»ºè®®MVPæ·»åŠ ** |
| **æ‰«æé¢„æ£€æŸ¥** | âŒ | âœ… | **å»ºè®®MVPæ·»åŠ ** |
| **ç»“æœå¯¼å‡º** | âŒ | âœ… | **å»ºè®®MVPæ·»åŠ ** |

---

## å››ã€ æœ€ç»ˆå»ºè®®æ¸…å•

### ç«‹å³ä¿®å¤ï¼ˆé˜»å¡æ€§é—®é¢˜ï¼‰

1. âœ… ä¿®æ­£æ•°æ®åº“è®¾è®¡ï¼Œåˆ†ç¦»å¤§å­—æ®µ
2. âœ… ä¼˜åŒ–CleanupPlanå†…å­˜å ç”¨
3. âœ… å¢åŠ AIè°ƒç”¨æˆæœ¬æ§åˆ¶
4. âœ… ç¡®ä¿UIçº¿ç¨‹å®‰å…¨ï¼ˆä½¿ç”¨QThreadï¼‰
5. âœ… ä¿®æ­£æ€§èƒ½æŒ‡æ ‡ï¼Œè®¾å®šåˆç†ç›®æ ‡

### MVPå¢å¼ºå»ºè®®ï¼ˆæå‡ç”¨æˆ·ä½“éªŒï¼‰

6. ğŸ’¡ æ·»åŠ è¿›åº¦é¢„ä¼°åŠŸèƒ½
7. ğŸ’¡ å®ç°æ‰«æé¢„æ£€æŸ¥
8. ğŸ’¡ æ”¯æŒæ‰«æç»“æœå¯¼å‡º
9. ğŸ’¡ ç®€åŒ–AIæ‰¹å¤„ç†ç­–ç•¥ï¼ˆä»…åˆ†æå¯ç–‘é¡¹ï¼‰

### V2è§„åˆ’å»ºè®®

10. ğŸ“Œ å®Œæ•´çš„å¤‡ä»½/å›æ»šæœºåˆ¶
11. ğŸ“Œ NTFS MFTå¿«é€Ÿæ‰«æ
12. ğŸ“Œ Treemapå¯è§†åŒ–
13. ğŸ“Œ æ‰«ææš‚åœ/æ¢å¤
14. ğŸ“Œ æ‰«æç»“æœå†å²æŸ¥è¯¢

---

## äº”ã€ æ›´æ–°åçš„æ—¶é—´ä¼°ç®—

### ä¿®æ­£åMVPå¼€å‘æ—¶é—´

| Phase | åŸé¢„ä¼° | ä¿®æ­£å | å˜æ›´åŸå›  |
|-------|-------|-------|---------|
| P1: åŸºç¡€æ¶æ„ | 1-2å¤© | 2å¤© | å¢åŠ æ•°æ®åº“ä¼˜åŒ– |
| P2: æ‰«æåŠŸèƒ½ | 2-3å¤© | 2å¤© | å»¶åMFTï¼Œç®€åŒ–æ‰«æ |
| P3: AIåˆ†æ | 2-3å¤© | 2å¤© | ç®€åŒ–æ‰¹å¤„ç†ç­–ç•¥ |
| P4: æ‰§è¡Œå™¨ | 2-3å¤© | 3å¤© | å¢åŠ çº¿ç¨‹å®‰å…¨æ”¹è¿› |
| P5: æŠ¥å‘Š | 1-2å¤© | 2å¤© | å¢åŠ å¯¼å‡ºåŠŸèƒ½ |
| P6: é›†æˆæµ‹è¯• | 1-2å¤© | 2å¤© | å¢åŠ æ€§èƒ½éªŒè¯ |
| **æ€»è®¡** | **10-14å¤©** | **13å¤©** | **åŸºæœ¬æŒå¹³** |

### V2é¢„è®¡å¼€å‘æ—¶é—´

| åŠŸèƒ½ | é¢„è®¡æ—¶é—´ |
|------|---------|
| å¤‡ä»½/å›æ»šæœºåˆ¶ | 3-4å¤© |
| NTFS MFTæ‰«æ | 5-7å¤© |
| Treemapå¯è§†åŒ– | 4-5å¤© |
| æš‚åœ/æ¢å¤åŠŸèƒ½ | 2-3å¤© |
| å†å²æŸ¥è¯¢åŠŸèƒ½ | 2-3å¤© |
| **V2æ€»è®¡** | **16-22å¤©** |

---

## å…­ã€ ç»“è®º

âœ… **æ–¹æ¡ˆæ•´ä½“è¯„ä¼°**: è®¾è®¡åˆç†ï¼Œæ¶æ„æ¸…æ™°ï¼Œå…·å¤‡å¯å®æ–½æ€§

âš ï¸ **å…³é”®æ”¹è¿›ç‚¹**:
1. æ•°æ®åº“å’Œå†…å­˜ä¼˜åŒ–ï¼ˆå¿…é¡»ä¿®å¤ï¼‰
2. AIæˆæœ¬æ§åˆ¶ï¼ˆå¿…é¡»ä¿®å¤ï¼‰
3. UIçº¿ç¨‹å®‰å…¨ï¼ˆå¿…é¡»ä¿®å¤ï¼‰
4. æ€§èƒ½æŒ‡æ ‡ä¿®æ­£ï¼ˆå¿…é¡»ä¿®æ­£ï¼‰
5. å¤‡ä»½/æ¢å¤æœºåˆ¶è¡¥å……ï¼ˆå»ºè®®è¡¥å……ï¼‰

ğŸ’¡ **MVPå¢å¼ºå»ºè®®**:
- è¿›åº¦é¢„ä¼°
- æ‰«æé¢„æ£€æŸ¥
- ç»“æœå¯¼å‡º

ğŸ“Œ **å»ºè®®æ‰§è¡Œ**:
1. ç«‹å³ä¿®å¤5ä¸ªå…³é”®é—®é¢˜
2. é‡‡çº³3ä¸ªMVPå¢å¼ºå»ºè®®
3. V2è§„åˆ’å¯å‚è€ƒ5é¡¹åŠŸèƒ½

**æœ€ç»ˆè¯„ä»·**: ä¿®å¤å…³é”®é—®é¢˜åï¼Œæ–¹æ¡ˆå¯è¿›å…¥å¼€å‘é˜¶æ®µã€‚

---

**å®¡æ ¸å®Œæˆæ—¶é—´**: 2026-02-21  
**å®¡æ ¸å»ºè®®ç‰ˆæœ¬**: v1.1